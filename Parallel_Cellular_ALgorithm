import math
import random

def f(path, points):
    total = 0
    for i in range(len(path) - 1):
        x1, y1 = points[path[i]]
        x2, y2 = points[path[i + 1]]
        total += math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return total

def update_rule(path, best_neighbor):
    new_path = path[:]
    i, j = random.sample(range(len(path)), 2)
    new_path[i], new_path[j] = best_neighbor[j], best_neighbor[i]
    return new_path

def parallel_cellular_algorithm():
    points = {
        0: (0, 0),
        1: (2, 3),
        2: (3, 1),
        3: (5, 4)
    }

    num_cells = 4
    max_iterations = 3

    cells = []
    for _ in range(num_cells):
        path = list(points.keys())
        random.shuffle(path)
        fitness = f(path, points)
        cells.append({'path': path, 'fitness': fitness})

    best_solution = min(cells, key=lambda c: c['fitness'])
    label_map = {0: 'A', 1: 'B', 2: 'C', 3: 'D'}

    for iteration in range(max_iterations):
        new_cells = []
        for cell in cells:
            best_neighbor = min(cells, key=lambda c: c['fitness'])
            new_path = update_rule(cell['path'], best_neighbor['path'])
            new_fitness = f(new_path, points)
            if new_fitness < cell['fitness']:
                new_cells.append({'path': new_path, 'fitness': new_fitness})
            else:
                new_cells.append(cell)

        cells = new_cells
        current_best = min(cells, key=lambda c: c['fitness'])
        if current_best['fitness'] < best_solution['fitness']:
            best_solution = current_best

        best_path_labels = [label_map[p] for p in best_solution['path']]
        print(f"Iteration {iteration + 1}: Best Path = {' → '.join(best_path_labels)}, Distance = {round(best_solution['fitness'], 4)}")

    best_path_labels = [label_map[p] for p in best_solution['path']]
    print("Final Best Path:", " → ".join(best_path_labels))
    print("Minimum Distance:", round(best_solution['fitness'], 4))

parallel_cellular_algorithm()
